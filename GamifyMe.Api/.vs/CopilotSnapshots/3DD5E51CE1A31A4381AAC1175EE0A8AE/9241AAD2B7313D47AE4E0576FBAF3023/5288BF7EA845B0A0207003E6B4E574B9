@using GamifyMe.Shared.Dtos
@using System.Net.Http.Json
@inject HttpClient Http

<div class="modal-backdrop @(IsOpen ? "show" : "")"></div>
<div class="modal @(IsOpen ? "show" : "")" tabindex="-1" style="display: @(IsOpen ? "block" : "none")">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Valider l'Objectif : <strong>@objectiveToScan?.Title</strong></h5>
                <button type="button" class="btn-close" @onclick="Close"></button>
            </div>
            <div class="modal-body">

                @if (!string.IsNullOrEmpty(scanMessage))
                {
                    <div class="alert @(isScanError ? "alert-danger" : "alert-success")">
                        @scanMessage
                    </div>
                }

                @if (IsOpen)
                {
                    <p>Scannez le QR code de l'utilisateur :</p>
                    <QrCodeScanner @ref="qrScannerRef" OnScanSuccess="HandleScanResult" />
                }
                else
                {
                }
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" @onclick="Close">Fermer</button>
            </div>
        </div>
    </div>
</div>

@code {
    private bool IsOpen = false;
    private ObjectiveDto? objectiveToScan;
    private string? scanMessage;
    private bool isScanError = false;

    // reference to child scanner component
    private QrCodeScanner? qrScannerRef;

    //1. Méthode publique asynchrone pour que le Dashboard puisse ouvrir ce modal
    // Démarre le scanner après le rendu afin d'éviter tout appel JS pendant le rendu initial.
    public async Task ShowAsync(ObjectiveDto objective)
    {
        objectiveToScan = objective;
        scanMessage = null;
        isScanError = false;
        IsOpen = true;

        // Force un rendu pour que le scanner child soit instancié et le @ref attribué
        await InvokeAsync(StateHasChanged);

        // Laisser le renderer terminer, puis démarrer le scanner de façon asynchrone
        await Task.Yield();

        if (qrScannerRef != null)
        {
            try
            {
                await qrScannerRef.StartAsync();
            }
            catch (Exception ex)
            {
                scanMessage = "Impossible de démarrer le scanner : " + ex.Message;
                isScanError = true;
                Console.WriteLine($"ScanValidationModal: erreur démarrage scanner: {ex.Message}");
            }
        }
    }

    // Backwards-compatible synchronous Show (fire-and-forget) — évite le blocage si parent n'await pas
    public void Show(ObjectiveDto objective)
    {
        _ = ShowAsync(objective);
    }

    //2. Méthode pour fermer
    public async void Close()
    {
        // Stopper proprement le scanner s'il tourne
        if (qrScannerRef != null)
        {
            try { await qrScannerRef.StopAsync(); } catch (Exception ex) { Console.WriteLine($"ScanValidationModal.Close stop error: {ex.Message}"); }
        }

        IsOpen = false;
        objectiveToScan = null;
        scanMessage = null;
        isScanError = false;
        StateHasChanged();
    }

    //3. Appelé par le <QrCodeScanner>
    private async Task HandleScanResult(string qrCode)
    {
        if (objectiveToScan == null) return;

        scanMessage = "Validation en cours...";
        isScanError = false;

        // On crée le DTO que l'API attend
        var request = new CreateValidationDto
        {
            ObjectiveId = objectiveToScan.Id,
            ScannedQrCodeContent = qrCode
        };

        try
        {
            var response = await Http.PostAsJsonAsync("api/validations", request);

            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<ValidationResponseDto>(); // On va devoir créer ça
                scanMessage = $"{result?.Message} (Nouvel XP: {result?.NewXpBalance})";
                isScanError = false;

                // Optionnel : arrêter le scanner après un succès pour éviter retriggers
                if (qrScannerRef != null) { await qrScannerRef.StopAsync(); }
            }
            else
            {
                scanMessage = await response.Content.ReadAsStringAsync();
                isScanError = true;
            }
        }
        catch (Exception ex)
        {
            scanMessage = $"Erreur : {ex.Message}";
            isScanError = true;
        }

        StateHasChanged(); // Affiche le message de succès/erreur
    }

    public async ValueTask DisposeAsync()
    {
        if (qrScannerRef != null)
        {
            try { await qrScannerRef.StopAsync(); } catch (Exception ex) { Console.WriteLine($"ScanValidationModal.Dispose stop error: {ex.Message}"); }
            qrScannerRef = null;
        }
    }
}