@page "/store"
@using GamifyMe.Shared.Dtos
@using GamifyMe.Shared.Models
@using GamifyMe.UI.Shared.Helpers
@using System.Net.Http.Json
@inject HttpClient Http
@inject ISnackbar Snackbar

<PageTitle>Boutique</PageTitle>

<MudContainer MaxWidth="MaxWidth.Medium" Class="mt-4 mb-16">
    <div class="d-flex justify-space-between align-center mb-6">
        <MudText Typo="Typo.h4" Color="Color.Primary">Boutique</MudText>
    </div>

    @if (isLoading)
    {
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" Class="ma-auto d-block" />
    }
    else if (storeItems == null || !storeItems.Any())
    {
        <MudAlert Severity="Severity.Info">La boutique est vide pour le moment.</MudAlert>
    }
    else
    {
        <MudGrid>
            @foreach (var item in storeItems)
            {
                <MudItem xs="6" sm="4" md="3">
                    <MudCard Elevation="3" Class="h-100 d-flex flex-column hover-elevation"
                        Style="@(userCurrencyBalance >= item.Price ? "border: 2px solid var(--mud-palette-success);" : "border: 2px solid var(--mud-palette-error);")">
                        @* ZONE IMAGE / ICÔNE *@
                        <div class="d-flex justify-center align-center pa-6"
                            style="background-color: var(--mud-palette-background-grey);">
                            <MudIcon Icon="@IconLibrary.GetIcon(item.IconName)" Style="font-size: 4rem;"
                                Color="@(userCurrencyBalance >= item.Price ? Color.Success : Color.Error)" />
                        </div>

                        <MudCardContent Class="flex-grow-1 pt-4">
                            <MudText Typo="Typo.subtitle1" Align="Align.Center"><b>@item.Name</b></MudText>
                            <MudText Typo="Typo.caption" Align="Align.Center" Class="d-block mt-1 text-muted">
                                @(string.IsNullOrEmpty(item.Description) ? "Aucune description" : item.Description)
                            </MudText>
                        </MudCardContent>

                        <MudCardActions Class="d-flex justify-center pb-4 px-4">
                            <MudButton Variant="Variant.Filled"
                                Color="@(userCurrencyBalance >= item.Price ? Color.Success : Color.Error)" FullWidth="true"
                                OnClick="() => PurchaseItem(item)"
                                Disabled="@(isPurchasing || userCurrencyBalance < item.Price)">
                                @if (isPurchasing)
                                {
                                    <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                                }
                                else
                                {
                                    <div class="d-flex align-center gap-1">
                                        <span>@(userCurrencyBalance >= item.Price ? "Acheter" : "Pas assez de fonds")</span>
                                        <MudChip T="string" Size="Size.Small" Color="Color.Surface" Variant="Variant.Text"
                                            Class="ml-2">@item.Price Pts</MudChip>
                                    </div>
                                }
                            </MudButton>
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }
</MudContainer>

@code {
    private List<StoreItemDto> storeItems = new();
    private bool isLoading = true;
    private bool isPurchasing = false;
    private int userCurrencyBalance = 0;

    protected override async Task OnInitializedAsync()
    {
        await LoadStoreItems();
    }

    private async Task LoadStoreItems()
    {
        isLoading = true;
        try
        {
            // On charge les items ET les infos utilisateur (pour le solde) en parallèle
            var itemsTask = Http.GetFromJsonAsync<List<StoreItemDto>>("api/store/active");
            var infoTask = Http.GetFromJsonAsync<InfoBarDto>("api/users/info-bar");

            await Task.WhenAll(itemsTask, infoTask);

            storeItems = itemsTask.Result ?? new List<StoreItemDto>();
            var info = infoTask.Result;

            // On récupère le solde de la monnaie principale (pas l'XP)
            // InfoBarDto a OtherWallets, on suppose que le premier est la monnaie
            if (info?.OtherWallets != null && info.OtherWallets.Any())
            {
                userCurrencyBalance = info.OtherWallets.First().Balance;
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Erreur de chargement : {ex.Message}", Severity.Error);
        }
        finally
        {
            isLoading = false;
        }
    }

    private async Task PurchaseItem(StoreItemDto item)
    {
        if (isPurchasing) return;
        isPurchasing = true;

        try
        {
            var response = await Http.PostAsync($"api/store/purchase/{item.Id}", null);

            if (response.IsSuccessStatusCode)
            {
                Snackbar.Add($"Vous avez acheté : {item.Name} !", Severity.Success);
                // On recharge pour mettre à jour le solde et le stock
                await LoadStoreItems();
            }
            else
            {
                var errorMsg = await response.Content.ReadAsStringAsync();
                Snackbar.Add($"Achat impossible : {errorMsg}", Severity.Error);
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Erreur technique : {ex.Message}", Severity.Error);
        }
        finally
        {
            isPurchasing = false;
        }
    }
}