@using GamifyMe.Shared.Dtos
@using System.Net.Http.Json
@inject HttpClient Http

@if (IsOpen)
{
    <div class="modal-backdrop show"></div>
    <div class="modal show" tabindex="-1" style="display: block;">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Valider l'Objectif : <strong>@objectiveToScan?.Title</strong></h5>
                    <button type="button" class="btn-close" @onclick="Close"></button>
                </div>
                <div class="modal-body">

                    @if (!string.IsNullOrEmpty(scanMessage))
                    {
                        <div class="alert @(isScanError ? "alert-danger" : "alert-success")">
                            @scanMessage
                        </div>
                    }

                    @if (_isScannerComponentActive) // <-- MODIFIEZ CECI
                    {
                        <p>Scannez le QR code de l'utilisateur :</p>
                        <QrCodeScanner @ref="qrScannerRef" OnScanSuccess="HandleScanResult" />
                    }

                </div>
                <div class="modal-footer">
                    @* J'ai aussi corrigé la faute de frappe ici *@
                    <button type="button" class="btn btn-secondary" @onclick="Close">Fermer</button>
                </div>
            </div>
        </div>
    </div>
}

@code {
    private bool IsOpen = false;
    private ObjectiveDto? objectiveToScan;
    private string? scanMessage;
    private bool isScanError = false;
    private bool _isScannerComponentActive = true;

    // reference to child scanner component
    private QrCodeScanner? qrScannerRef;

    //1. Méthode publique asynchrone pour que le Dashboard puisse ouvrir ce modal
    // Démarre le scanner après le rendu afin d'éviter tout appel JS pendant le rendu initial.
    public async Task ShowAsync(ObjectiveDto objective)
    {
        objectiveToScan = objective;
        scanMessage = null;
        isScanError = false;
        IsOpen = true;

        // Force un rendu pour que le scanner child soit instancié et le @ref attribué
        await InvokeAsync(StateHasChanged);

        // Laisser le renderer terminer, puis démarrer le scanner de façon asynchrone
        await Task.Yield();

        if (qrScannerRef != null)
        {
            try
            {
                await qrScannerRef.StartAsync();
            }
            catch (Exception ex)
            {
                scanMessage = "Impossible de démarrer le scanner : " + ex.Message;
                isScanError = true;
                Console.WriteLine($"ScanValidationModal: erreur démarrage scanner: {ex.Message}");
            }
        }
    }

    // Backwards-compatible synchronous Show (fire-and-forget) — évite le blocage si parent n'await pas
    public void Show(ObjectiveDto objective)
    {
        _ = ShowAsync(objective);
    }

    //2. Méthode pour fermer
    public async void Close()
    {
        // Stopper proprement le scanner s'il tourne
        if (qrScannerRef != null)
        {
            try { await qrScannerRef.StopAsync(); } catch (Exception ex) { Console.WriteLine($"ScanValidationModal.Close stop error: {ex.Message}"); }
        }

        IsOpen = false;
        objectiveToScan = null;
        scanMessage = null;
        isScanError = false;
        StateHasChanged();
    }

    //3. Appelé par le <QrCodeScanner>
    private async Task HandleScanResult(string qrCode)
    {
        if (objectiveToScan == null) return;

        // 1. DÉTRUIRE LE COMPOSANT SCANNER
        // (En mettant le @if à false, Blazor va le supprimer du DOM et appeler son Dispose)
        _isScannerComponentActive = false;
        scanMessage = null;
        isScanError = false;
        await InvokeAsync(StateHasChanged);
        qrScannerRef = null; // On s'assure que l'ancienne référence est partie

        // ... (Logique d'appel API inchangée) ...
        var request = new CreateValidationDto { /* ... */ };
        try
        {
            var response = await Http.PostAsJsonAsync("api/validations", request);
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<ValidationResponseDto>();
                scanMessage = $"{result?.Message} (Nouvel XP: {result?.NewXpBalance})";
                isScanError = false;
            }
            else
            {
                scanMessage = await response.Content.ReadAsStringAsync();
                isScanError = true;
            }
        }
        catch (Exception ex) { /* ... */ }

        // 2. AFFICHER LE RÉSULTAT (sans scanner)
        await InvokeAsync(StateHasChanged);

        // 3. PAUSE pour la lecture
        await Task.Delay(2000);

        // 4. PRÉPARER LA RECRÉATION
        scanMessage = null;
        isScanError = false;
        _isScannerComponentActive = true; // On dit à Blazor de recréer le composant
        await InvokeAsync(StateHasChanged); // Blazor recrée le scanner

        // 5. ATTENDRE QUE BLazor ASSIGNE LE NOUVEAU @ref
        // C'est crucial, il faut laisser le temps au moteur de rendu.
        await Task.Yield();

        // 6. DÉMARRER LA NOUVELLE INSTANCE DU SCANNER
        try
        {
            if (qrScannerRef != null)
            {
                await qrScannerRef.StartAsync(); // Démarrer la NOUVELLE instance
            }
            else
            {
                throw new Exception("Référence du scanner non réassignée.");
            }
        }
        catch (Exception ex)
        {
            scanMessage = "Erreur au redémarrage du scanner: " + ex.Message;
            isScanError = true;
            await InvokeAsync(StateHasChanged);
        }
    }


    // ==================================================
    // BLOC DE TRACAGE SYSTÉMATIQUE
    // ==================================================

    protected override void OnInitialized()
    {
        Console.WriteLine("TRACE: MODAL - OnInitialized START");
        base.OnInitialized();
        Console.WriteLine("TRACE: MODAL - OnInitialized END");
    }

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("TRACE: MODAL - OnInitializedAsync START");
        await base.OnInitializedAsync();
        Console.WriteLine("TRACE: MODAL - OnInitializedAsync END");
    }

    protected override void OnParametersSet()
    {
        Console.WriteLine("TRACE: MODAL - OnParametersSet START");
        base.OnParametersSet();
        Console.WriteLine("TRACE: MODAL - OnParametersSet END");
    }

    protected override async Task OnParametersSetAsync()
    {
        Console.WriteLine("TRACE: MODAL - OnParametersSetAsync START");
        await base.OnParametersSetAsync();
        Console.WriteLine("TRACE: MODAL - OnParametersSetAsync END");
    }

    protected override void OnAfterRender(bool firstRender)
    {
        Console.WriteLine($"TRACE: MODAL - OnAfterRender START (firstRender: {firstRender})");
        base.OnAfterRender(firstRender);
        Console.WriteLine($"TRACE: MODAL - OnAfterRender END (firstRender: {firstRender})");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"TRACE: MODAL - OnAfterRenderAsync START (firstRender: {firstRender})");
        await base.OnAfterRenderAsync(firstRender);
        Console.WriteLine($"TRACE: MODAL - OnAfterRenderAsync END (firstRender: {firstRender})");
    }

    // LA MÉTHODE CORRIGÉE (avec les traces)
    public async ValueTask DisposeAsync()
    {
        Console.WriteLine("TRACE: MODAL - DisposeAsync START"); // <-- AJOUTEZ CECI

        if (qrScannerRef != null)
        {
            try { await qrScannerRef.StopAsync(); } catch (Exception ex) { Console.WriteLine($"ScanValidationModal.Dispose stop error: {ex.Message}"); }
            qrScannerRef = null;
        }

        Console.WriteLine("TRACE: MODAL - DisposeAsync END"); // <-- AJOUTEZ CECI
    }
}